<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FR 先鋒科技 - 量子百萬粒子系統</title>
    <style>
        :root { --neon: #bc13fe; --cyan: #00f3ff; }
        * { margin: 0; padding: 0; box-sizing: border-box; overflow: hidden; touch-action: none; background: #000; }
        
        /* 頂級邊框：增加光流感 */
        body::after {
            content: ''; position: fixed; inset: 0; border: 2px solid transparent;
            border-image: conic-gradient(from var(--angle), var(--cyan), var(--neon), #fff, var(--neon), var(--cyan)) 1;
            z-index: 100; pointer-events: none;
            filter: drop-shadow(0 0 10px var(--neon));
            animation: rotateGradient 1.5s linear infinite;
        }
        @property --angle { syntax: '<angle>'; initial-value: 0deg; inherits: false; }
        @keyframes rotateGradient { to { --angle: 360deg; } }

        #overlay {
            position: fixed; top: 20px; left: 20px; z-index: 200;
            color: #fff; font-family: 'Segoe UI', sans-serif;
            font-size: 10px; letter-spacing: 2px; opacity: 0.6; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="overlay">FR_TECH_SYSTEM: 200,000_PARTICLES // GPU_ACCELERATED</div>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, geometry, material, points;
        let particleCount = 200000; // 預設 20 萬，可改為 1000000
        let mouse = new THREE.Vector2(-1000, -1000);
        let targetMouse = new THREE.Vector2(-1000, -1000);
        let isPressing = false;

        // --- Shader 程式碼：這是萬級粒子流暢的關鍵 ---
        const _VS = `
            uniform float uTime;
            uniform vec2 uMouse;
            uniform float uPress;
            attribute float aSize;
            attribute vec3 aVelocity;
            varying vec3 vColor;

            void main() {
                vec3 pos = position;
                
                // 計算與滑鼠距離
                float dist = distance(pos.xy, uMouse);
                
                // 引力/斥力演算法
                if(uPress > 0.5) {
                    vec2 dir = normalize(pos.xy - uMouse);
                    float force = (500.0 - min(dist, 500.0)) / 500.0;
                    pos.xy -= dir * force * 15.0; // 強大吸引力
                }

                // 基礎流動動畫
                pos.x += sin(uTime * 0.5 + pos.y * 0.01) * 2.0;
                pos.y += cos(uTime * 0.5 + pos.x * 0.01) * 2.0;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = aSize * (1000.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;

                // 顏色隨位置動態變化 (紫到青)
                vColor = mix(vec3(0.74, 0.07, 1.0), vec3(0.0, 0.95, 1.0), sin(pos.x * 0.005) * 0.5 + 0.5);
            }
        `;

        const _FS = `
            varying vec3 vColor;
            void main() {
                float d = distance(gl_PointCoord, vec2(0.5));
                if(d > 0.5) discard;
                gl_FragColor = vec4(vColor, 0.8 * (0.5 - d));
            }
        `;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.z = 800;

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            const pos = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                pos[i * 3] = (Math.random() - 0.5) * 2000;
                pos[i * 3 + 1] = (Math.random() - 0.5) * 2000;
                pos[i * 3 + 2] = (Math.random() - 0.5) * 500;
                sizes[i] = Math.random() * 2.0 + 0.5;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));

            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uMouse: { value: new THREE.Vector2(0, 0) },
                    uPress: { value: 0 }
                },
                vertexShader: _VS,
                fragmentShader: _FS,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);

            // 事件監聽
            window.addEventListener('pointermove', e => {
                targetMouse.x = e.clientX - window.innerWidth / 2;
                targetMouse.y = -(e.clientY - window.innerHeight / 2);
            });
            window.addEventListener('pointerdown', () => { 
                isPressing = true;
                if(navigator.vibrate) navigator.vibrate(50); // 強烈震動
            });
            window.addEventListener('pointerup', () => isPressing = false);
            window.addEventListener('resize', onResize);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate(time) {
            requestAnimationFrame(animate);
            
            // 平滑跟隨滑鼠
            mouse.lerp(targetMouse, 0.1);
            
            material.uniforms.uTime.value = time * 0.002;
            material.uniforms.uMouse.value.copy(mouse);
            material.uniforms.uPress.value = isPressing ? 1.0 : 0.0;

            // 隨機抖動：增加電影感
            if(isPressing) {
                camera.position.x += (Math.random() - 0.5) * 5;
                camera.position.y += (Math.random() - 0.5) * 5;
            } else {
                camera.position.x *= 0.95;
                camera.position.y *= 0.95;
            }

            renderer.render(scene, camera);
        }

        init();
        animate(0);
    </script>
</body>
</html>
