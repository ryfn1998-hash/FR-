<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ULTIMATE QUANTUM CORE</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; touch-action: none; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* 初始啟動層 */
        #boot-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            background: #000; color: #00f3ff; z-index: 100; cursor: pointer;
            letter-spacing: 10px; font-weight: 100; transition: opacity 1s;
        }

        #hud {
            position: fixed; top: 20px; left: 20px; color: rgba(0, 243, 255, 0.4);
            font-family: monospace; font-size: 10px; pointer-events: none;
            letter-spacing: 1px; z-index: 50;
        }

        /* 閃爍效果 */
        .scanline {
            width: 100%; height: 100%; position: absolute; top: 0; left: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.2) 50%),
                        linear-gradient(90deg, rgba(255, 0, 0, 0.05), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.05));
            background-size: 100% 4px, 3px 100%; pointer-events: none; z-index: 10;
        }
    </style>
</head>
<body>

<div id="boot-layer">INITIALIZE CORE</div>
<div id="hud">SYSTEM: ONLINE // PARTICLES: 100,000 // FORCE: MULTI-TOUCH</div>
<div class="scanline"></div>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

    let scene, camera, renderer, points, geometry;
    const particleCount = 100000; // 十萬顆粒子，挑戰極限
    let positions, velocities, colors;
    let isPressing = false;
    let touches = [];

    const init = () => {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.z = 500;

        renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        geometry = new THREE.BufferGeometry();
        positions = new Float32Array(particleCount * 3);
        velocities = new Float32Array(particleCount * 3);
        colors = new Float32Array(particleCount * 3);

        const colorPool = [new THREE.Color(0x00f3ff), new THREE.Color(0x7000ff), new THREE.Color(0xffffff)];

        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 1500;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 1500;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 1000;

            const c = colorPool[Math.floor(Math.random() * colorPool.length)];
            colors[i * 3] = c.r;
            colors[i * 3 + 1] = c.g;
            colors[i * 3 + 2] = c.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 1.0,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.6,
            depthWrite: false
        });

        points = new THREE.Points(geometry, material);
        scene.add(points);

        setupListeners();
    };

    const setupListeners = () => {
        const boot = document.getElementById('boot-layer');
        boot.onclick = () => {
            boot.style.opacity = 0;
            setTimeout(() => boot.remove(), 1000);
            if (navigator.vibrate) navigator.vibrate([50, 30, 100]);
            animate();
        };

        const updateTouches = (e) => {
            e.preventDefault();
            const rawTouches = e.touches ? Array.from(e.touches) : [e];
            touches = rawTouches.map(t => {
                const x = (t.clientX / window.innerWidth) * 2 - 1;
                const y = -(t.clientY / window.innerHeight) * 2 + 1;
                const vec = new THREE.Vector3(x, y, 0.5).unproject(camera);
                const dir = vec.sub(camera.position).normalize();
                return camera.position.clone().add(dir.multiplyScalar(-camera.position.z / dir.z));
            });
        };

        window.addEventListener('mousedown', (e) => { isPressing = true; updateTouches(e); });
        window.addEventListener('touchstart', (e) => { isPressing = true; updateTouches(e); });
        window.addEventListener('mousemove', updateTouches);
        window.addEventListener('touchmove', updateTouches);
        
        window.addEventListener('mouseup', () => explode());
        window.addEventListener('touchend', () => explode());
    };

    const explode = () => {
        isPressing = false;
        // 超新星爆炸觸覺反饋
        if (navigator.vibrate) navigator.vibrate([10, 50, 10, 100]);
        // 給予所有粒子向外的衝力
        const pos = geometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
            velocities[i * 3] *= -5;
            velocities[i * 3 + 1] *= -5;
        }
    };

    const animate = () => {
        requestAnimationFrame(animate);
        const posAttr = geometry.attributes.position;
        const pos = posAttr.array;

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            if (isPressing && touches.length > 0) {
                // 多指引力場
                touches.forEach(t => {
                    const dx = t.x - pos[i3];
                    const dy = t.y - pos[i3 + 1];
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 600) {
                        const force = (1 - dist / 600) * 0.8;
                        velocities[i3] += dx * force * 0.02;
                        velocities[i3 + 1] += dy * force * 0.02;
                    }
                });
                velocities[i3] *= 0.92;
                velocities[i3 + 1] *= 0.92;
            } else {
                velocities[i3] *= 0.98;
                velocities[i3 + 1] *= 0.98;
            }

            pos[i3] += velocities[i3];
            pos[i3 + 1] += velocities[i3 + 1];

            // 隨機動能，防止粒子死掉
            pos[i3] += (Math.random() - 0.5) * 0.2;
            pos[i3 + 1] += (Math.random() - 0.5) * 0.2;
        }

        posAttr.needsUpdate = true;

        // 鏡頭震盪特效
        if (isPressing) {
            camera.position.x += (Math.random() - 0.5) * 4;
            camera.position.y += (Math.random() - 0.5) * 4;
            if (Math.random() > 0.9 && navigator.vibrate) navigator.vibrate(5);
        } else {
            camera.position.x *= 0.9;
            camera.position.y *= 0.9;
        }

        renderer.render(scene, camera);
    };

    init();
</script>
</body>
</html>
